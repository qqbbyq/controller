@startuml

participant DataTreeChangeListenerProxy as a << (C,#ADD1B2) >>
[->  a : DTCLP(context,listener,registeredPath)
activate a

create DataTreeChangeListenerActor as b << (C,#ADD1B2) >>
a -> b : props(listener,path)
b --> a : dTCLActor
deactivate a
====
[-> a : init(shardName)
activate a
a -> a: doRegistration(shard)
activate a
participant "Shard(Actor)" as c << (C,#ADD1B2) >>
participant DataTreeChangeListenerSupport as e << (C,#ADD1B2)>>
a -> c : ?RegisterDTCL(path,dTCLActor,isCluster):r
c -> e: onMessage(r,isleader,hasleader)
activate e
e -> e: createDelegate(r)
activate e
create ForwardingDataTreeChangeListener as f <<I, #ADD1B2>>
e -> f: FDTCL(dTCLActorPath)
f --> e: fowradingListener

participant ShardDataTree as sdt << (C,#ADD1B2) >>
participant ShardDataTreeChangeListenerPublisher as sdtp <<(I, #add1b2)>>
e -> sdt: registerTCL(path, forwardingListener)
sdt -> sdtp:registerTCL(path, forwardingListener)
sdtp --> sdt: ListenerRegistration(forwardingListener)
sdt --> e: Entry<registration:ListenerRegistration<ForwardingDTCListener>, currState:DataTreeCandidate>
note left
将dataTreeChangeListenerActorPath
追加到listenerActors。一个registration
对应一个dataTreeChangeListenerActorPath,
将registration重新包装，
若registration.close,则从listenerActors移除
end note
e -> sdt: notifyOfInitialData(path,forwardingListener,currState )

sdt -> sdtp: newInstance() && registerTCL
sdt -> sdtp: publishChanges(currState,context)
sdtp -> f: onDataChanged
f -> b: !DataTreeChanged(changes)
b ->[: listener.onDataTreeChanged()
deactivate e
create DataTreeChangeListenerRegistrationActor as d <<(C, #ADD1B2) >>

e -> d: newRegistrationActor(registration)
d --> e: registrationActor
e -> a: !RegisterDTCLReply(registrationActor)

deactivate e
deactivate a

a -> a: setListenerRegistrationActor(registrationActor)
a -->[
deactivate a

====
[-> a : removeRegistration()
activate a
a ->x d: CloseDTCLRegistration
a ->x b:!PoisonPill
deactivate a


@enduml